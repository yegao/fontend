# JavaScript

## 数据类型

### 原始值

原始值就是不能更改的值。例如（与C语言不同），字符串是不可变的。我们将这些类型的值称为原始值。

#### Boolean类型

Boolean表示逻辑实体，具有两种值：true和false。

#### Null类型

Null类型只有一个值：null。

#### Undefined类型

Undefined类型只有一个值：undefined，未主动分配值的变量的默认值就是undefined。

#### Number类型

Number类型是双精度64位二进制格式IEEE 754值（负2的53次方减1 到 正2的53次方减1之间的数字）。除了表示浮点数，数字类型还具有三个符号值：+ Infinity，-Infinity和NaN（"非数字"）。要检查±Infinity内的最大可用值或最小可用值，可以使用常数Number.MAX_VALUE或Number.MIN_VALUE。

#### BigInt类型

BigInt类型可以表示任意精度的整数。 使用BigInt，您可以安全地存储和操作大整数，甚至可以超出Numbers的安全整数限制。
可以通过将n附加到整数的末尾或调用构造函数来创建BigInt。

```js
var x1 = 999999999999999n; // typeof x1 === "bigint"
var x2 = BigInt(999999999999999); // typeof x2 === "bigint"
```

#### String类型

String类型用于表示文本数据。它是由一组16位无符号整数值的元素组合而成。第一个元素在索引0处，第二个元素在索引1处，依此类推。字符串的长度是其中的元素个数。
与某些编程语言（例如C）不同，JavaScript字符串是不可变的。这意味着一旦创建了字符串，就无法对其进行修改。但是，仍然可以基于对原始字符串的操作来创建另一个字符串。例如：

* 通过索引或使用`String.substr()`来获取原始字符串的子字符串。
* 使用串联运算符`+`或`String.concat()`对两个字符串进行串联。

#### Symbol类型

Symbol类型的值是唯一且不可变的原始值，可以用作Object属性的键。

### 对象

在计算机科学中，对象是内存中的值，可能由标识符引用。在JavaScript中，对象可以看作是属性的集合。使用`{}`语法，可以初始化一组有限的属性，然后就可以添加和删除属性。属性值可以是任何类型的值，包括其他对象，从而可以构建复杂的数据结构。键值可以是String类型的值或Symbol类型的值。

### 小结

最新的ECMAScript标准定义了7种原始类型，其中6中原始类型可以用typeof运算符检测:

* undefined :  typeof x === "undefined"
* Boolean   :  typeof x === "boolean"
* Number    :  typeof x === "number"
* String    :  typeof x === "string"
* BigInt    :  typeof x === "bigint"
* Symbol    :  typeof x === "symbol"

Null类型是一种特殊的原始类型，typeof x === "object"，如果一个对象没有继承任何其他的对象，则在其原型链的末端会是null。

另外还有一种复杂类型，为Object类型。

## 变量

### 变量的作用域

一个变量的作用域是程序源代码中定义这个变量的区域，全局变量拥有全局作用域，在ECMAScript 6 之前，JavaScript没有块级作用域，但是有函数作用域，在ECMAScript 6 中，新增了let、const的用法，使用let、const定义的变量属于块级作用域。

#### 全局作用域

如果在声明变量的时候没有使用var、let、const等，那么声明的将是一个全局变量。或者声明变量的时候没有使用函数包裹，该变量也是全局变量。全局变量可以被任何其他代码所访问。

#### 函数作用域

在函数内部使用var声明的变量只能在*该函数*的内部可见。

```txt
---注释---
该函数：指包裹着这个变量且离该变量最近的函数。
```

#### 块级作用域

在一些类似C语言的编程语言中，花括号内的每一段代码都有各自的作用域，变量在声明他们的代码段之外是不可见的，我们称之为块级作用域。
ECMAScript 6 中使用let、const定义的变量属于块级作用域。

```js
if (true) {
  let x = 5;
}
console.log(x); // ReferenceError: x is not defined
```

### 作用域链

JavaScript是基于词法作用域的语言，通过阅读包含变量定义在内的数行源码就可以知道变量的作用域。全局变量在程序中始终都是有定义的，局部变量在声明它的函数体内以及其所嵌套的函数内是有定义的。

如果将一个局部变量看成是一个对象的属性的话，那么可以换个角度区解读变量作用域。在每段JavaScript代码（全局代码或者函数）都有一个与之关联的作用域链（scope chain）。这个作用域链是一个对象列表或者链表，这组对象定义了这段代码对应的作用域中的变量。当JavaScript需要查找变量x的值的时候（这个过程称之为“变量解析”），它会从链中的第一个对象开始查找，如果这个对象中有一个名为x的属性，则会直接使用这个属性的值，如果第一个对象中不存在名为x的属性，则继续查找下一个对象，以此类推。如果作用域链上没有任何一个对象含有属性x，那么就认为这段代码的作用域链上不存在x，并最终跑出一个引用错误异常（ReferenceError）。

* 在JavaScript最顶层的代码中（也就是不包含在任何函数定义内的代码），作用域链由一个全局对象组成。
* 在不包含嵌套函数的函数体内，作用域链上有两个对象，第一个是定义函数参数和局部变量的对象，第二个是全局对象。
* 在一个嵌套的函数体内，作用域链上至少有三个对象。

#### 作用域链的创建规则

当定义一个函数的时候，实际上保存了一个作用域链，当调用这个函数的时候，JavaScript会创建一个存储了这个函数的局部变量的对象，并将这个对象添加到那个作用域链上。对于嵌套函数来讲，每次调用外部函数的时候，内部函数又会重新定义一遍，因为每次调用外部函数的时候，作用域链都是不同的。

## 函数

### 函数声明

### 函数表达式

### 函数提升

### 函数作用域链

### 闭包

#### 术语来源

闭包这个术语非常古老，它是指函数变量可以被隐藏于作用域之内，看起来就像是函数将变量包裹了起来。

#### 本质

JavaScript采用了词法作用域，函数的执行依赖于变量的作用域，这个作用域是在函数定义的时候就决定了的。JavaScript函数对象的内部状态不仅包含函数的代码逻辑，还必须引用当前的作用域链。函数对象可以通过作用域链相互关联，函数体内部的变量都可以保存在函数作用域内，这种特性在计算机科学中称之为`闭包`。
当调用函数的时候定闭包所指向的作用域链和定义函数的时候闭包所指向的作用域链不同的时候事情就变得很微妙。

很多人认为函数在执行结束之后，与之相关的作用域链似乎也不存在了，但是其实在JavaScript中并非如此。如果一个函数的局部变量定义在CPU的栈中，那么当函数返回时他们的确就不存在了。但是作用域链其实是一个对象列表，不是绑定的栈。每次调用JavaScript函数的时候，都会为之创建一个新的对象用来保存局部变量，然后把这个对象添加到作用域链中。当函数返回的时候，就从作用域链中将这个绑定变量的对象删除。

* 如果不存在嵌套的函数，也没有其他引用指向这个绑定对象，它就会被当作垃圾回收掉。
* 如果定义了嵌套的函数，每个嵌套的函数都各自对应一个作用域链。并且这个作用域链指向一个变量绑定对象。但如果这些嵌套的函数对象在外部函数中保存下来，那么它们也会和所指向的变量绑定对象一样被当作垃圾回收。

```js
function outer(){
  var x = "x"
  function inner(){
    var y = "y";
  }
}
outer();
```

* 如果这个函数定义了嵌套的函数，并且将它作为返回值返回或者存放在某个属性里面，这时候就会有一个外部引用指向这嵌套的函数。它就不会被当作垃圾回收，并且它所指向的变量绑定对象也不会被当作垃圾回收。

```js
function outer(){
  var x = "x"
  function inner(){
    var y = "y";
  }
  return inner;
}
```

```js
var o = {};
function outer(){
  var x = "x"
  function inner(){
    var y = "y";
  }
  o.inner = inner;
}
```
