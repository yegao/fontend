# JavaScript

## 数据类型

### 原始值

原始值就是不能更改的值。例如（与C语言不同），字符串是不可变的。我们将这些类型的值称为原始值。

#### Boolean类型

Boolean表示逻辑实体，具有两种值：true和false。

#### Null类型

Null类型只有一个值：null。

#### Undefined类型

Undefined类型只有一个值：undefined，未主动分配值的变量的默认值就是undefined。

#### Number类型

Number类型是双精度64位二进制格式IEEE 754值（负2的53次方减1 到 正2的53次方减1之间的数字）。除了表示浮点数，数字类型还具有三个符号值：+ Infinity，-Infinity和NaN（"非数字"）。要检查±Infinity内的最大可用值或最小可用值，可以使用常数Number.MAX_VALUE或Number.MIN_VALUE。

#### BigInt类型

BigInt类型可以表示任意精度的整数。 使用BigInt，您可以安全地存储和操作大整数，甚至可以超出Numbers的安全整数限制。
可以通过将n附加到整数的末尾或调用构造函数来创建BigInt。

```js
var x1 = 999999999999999n; // typeof x1 === "bigint"
var x2 = BigInt(999999999999999); // typeof x2 === "bigint"
```

#### String类型

String类型用于表示文本数据。它是由一组16位无符号整数值的元素组合而成。第一个元素在索引0处，第二个元素在索引1处，依此类推。字符串的长度是其中的元素个数。
与某些编程语言（例如C）不同，JavaScript字符串是不可变的。这意味着一旦创建了字符串，就无法对其进行修改。但是，仍然可以基于对原始字符串的操作来创建另一个字符串。例如：

* 通过索引或使用`String.substr()`来获取原始字符串的子字符串。
* 使用串联运算符`+`或`String.concat()`对两个字符串进行串联。

#### Symbol类型

Symbol类型的值是唯一且不可变的原始值，可以用作Object属性的键。

### 对象

在计算机科学中，对象是内存中的值，可能由标识符引用。在JavaScript中，对象可以看作是属性的集合。使用`{}`语法，可以初始化一组有限的属性，然后就可以添加和删除属性。属性值可以是任何类型的值，包括其他对象，从而可以构建复杂的数据结构。键值可以是String类型的值或Symbol类型的值。

### 小结

最新的ECMAScript标准定义了7种原始类型，其中6中原始类型可以用typeof运算符检测:

* undefined :  typeof x === "undefined"
* Boolean   :  typeof x === "boolean"
* Number    :  typeof x === "number"
* String    :  typeof x === "string"
* BigInt    :  typeof x === "bigint"
* Symbol    :  typeof x === "symbol"

Null类型是一种特殊的原始类型，typeof x === "object"，如果一个对象没有继承任何其他的对象，则在其原型链的末端会是null。

另外还有一种复杂类型，为Object类型。

## 变量

### 变量的作用域

在函数之外声明的变量，叫做全局变量，因为它可被当前文档中的任何其他代码所访问。在函数内部声明的变量，叫做局部变量，因为它只能在当前函数的内部访问。

ECMAScript 6 之前的 JavaScript 没有语句块作用域；相反，语句块中声明的变量将成为语句块所在函数（或全局作用域）的局部变量。例如，如下的代码将在控制台输出 5，因为 x 的作用域是声明了 x 的那个函数（或全局范围），而不是 if 语句块。

```js
if (true) {
  var x = 5;
}
console.log(x); // 5
```

如果使用 ECMAScript 6 中的 let 声明，上述行为将发生变化。

```js
if (true) {
  let x = 5;
}
console.log(x); // ReferenceError: x 没有被声明
```

## 函数

### 函数声明

### 函数表达式

### 函数提升

### 函数作用域链

### 闭包

#### 术语来源

`闭包`这个术语非常古老，它是指函数变量可以被隐藏于作用域之内，看起来就像是函数将变量`包裹`了起来。

#### 本质

JavaScript采用了词法作用域，函数的执行依赖于变量的作用域，这个作用域是在函数定义的时候就决定了的。JavaScript函数对象的内部状态不仅包含函数的代码逻辑，还必须引用当前的作用域链。函数对象可以通过作用域链相互关联，函数体内部的变量都可以保存在函数作用域内，这种特性在计算机科学中称之为`闭包`。
当调用函数的时候定闭包所指向的作用域链和定义函数的时候闭包所指向的作用域链不同的时候事情就变得很微妙。

很多人认为函数在执行结束之后，与之相关的作用域链似乎也不存在了，但是其实在JavaScript中并非如此。如果一个函数的局部变量定义在CPU的栈中，那么当函数返回时他们的确就不存在了。但是作用域链其实是一个对象列表，不是绑定的栈。每次调用JavaScript函数的时候，都会为之创建一个新的对象用来保存局部变量，然后把这个对象添加到作用域链中。当函数返回的时候，就从作用域链中将这个绑定变量的对象删除。

* 如果不存在嵌套的函数，也没有其他引用指向这个绑定对象，它就会被当作垃圾回收掉。
* 如果定义了嵌套的函数，每个嵌套的函数都各自对应一个作用域链。并且这个作用域链指向一个变量绑定对象。但如果这些嵌套的函数对象在外部函数中保存下来，那么它们也会和所指向的变量绑定对象一样被当作垃圾回收。

```js
function outer(){
  var x = "x"
  function inner(){
    var y = "y";
  }
}
outer();
```

* 如果这个函数定义了嵌套的函数，并且将它作为返回值返回或者存放在某个属性里面，这时候就会有一个外部引用指向这嵌套的函数。它就不会被当作垃圾回收，并且它所指向的变量绑定对象也不会被当作垃圾回收。

```js
function outer(){
  var x = "x"
  function inner(){
    var y = "y";
  }
  return inner;
}
```

```js
var o = {};
function outer(){
  var x = "x"
  function inner(){
    var y = "y";
  }
  o.inner = inner;
}
```
